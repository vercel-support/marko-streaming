{"version":3,"file":"_DkqK2axP.js","sources":["../../../node_modules/.pnpm/marko@6.0.0/node_modules/marko/dist/dom.mjs"],"sourcesContent":["// src/common/attr-tag.ts\nvar empty = [], rest = Symbol();\nfunction attrTag(attrs2) {\n  return attrs2[Symbol.iterator] = attrTagIterator, attrs2[rest] = empty, attrs2;\n}\nfunction attrTags(first, attrs2) {\n  return first ? (first[rest] === empty ? first[rest] = [attrs2] : first[rest].push(attrs2), first) : attrTag(attrs2);\n}\nfunction* attrTagIterator() {\n  yield this, yield* this[rest];\n}\n\n// src/common/for.ts\nfunction forIn(obj, cb) {\n  for (let key in obj)\n    cb(key, obj[key]);\n}\nfunction forOf(list, cb) {\n  if (list) {\n    let i = 0;\n    for (let item of list)\n      cb(item, i++);\n  }\n}\nfunction forTo(to, from, step, cb) {\n  let start = from || 0, delta = step || 1;\n  for (let steps = (to - start) / delta, i = 0; i <= steps; i++)\n    cb(start + i * delta);\n}\n\n// src/common/helpers.ts\nfunction classValue(value2) {\n  return toDelimitedString(value2, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name, value2) {\n  return value2 ? name : \"\";\n}\nfunction styleValue(value2) {\n  return toDelimitedString(value2, \";\", stringifyStyleObject);\n}\nfunction stringifyStyleObject(name, value2) {\n  return value2 || value2 === 0 ? `${name}:${typeof value2 == \"number\" && value2 && !/^(--|ta|or|li|z)|cou|nk|it|ag|we|do|w$/.test(name) ? value2 + \"px\" : value2}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\", curDelimiter = \"\";\n        if (Array.isArray(val))\n          for (let v of val) {\n            let part = toDelimitedString(v, delimiter, stringify);\n            part !== \"\" && (result += curDelimiter + part, curDelimiter = delimiter);\n          }\n        else\n          for (let name in val) {\n            let v = val[name], part = stringify(name, v);\n            part !== \"\" && (result += curDelimiter + part, curDelimiter = delimiter);\n          }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isEventHandler(name) {\n  return /^on[A-Z-]/.test(name);\n}\nfunction getEventHandlerName(name) {\n  return name[2] === \"-\" ? name.slice(3) : name.slice(2).toLowerCase();\n}\nfunction normalizeDynamicRenderer(value2) {\n  return value2 ? value2.content || value2.default || value2 : void 0;\n}\n\n// src/dom/event.ts\nvar defaultDelegator = createDelegator();\nfunction on(element, type, handler) {\n  element[\"$\" + type] === void 0 && defaultDelegator(element, type, handleDelegated), element[\"$\" + type] = handler || null;\n}\nfunction createDelegator() {\n  let kEvents = Symbol();\n  return function(node, type, handler) {\n    ((node = node.getRootNode())[kEvents] ||= {})[type] ||= (node.addEventListener(type, handler, !0), 1);\n  };\n}\nfunction handleDelegated(ev) {\n  let target = !rendering && ev.target;\n  for (; target; )\n    target[\"$\" + ev.type]?.(ev, target), target = ev.bubbles && !ev.cancelBubble && target.parentNode;\n}\n\n// src/dom/resolve-cursor-position.ts\nfunction resolveCursorPosition(inputType2, initialPosition, initialValue, updatedValue) {\n  if (\n    // If initial position is null or false then\n    // either this node is not the active element\n    // or does not support selection ranges.\n    (initialPosition || initialPosition === 0) && (initialPosition !== initialValue.length || // short regex to match input types that delete backwards\n    /kw/.test(inputType2))\n  ) {\n    let before = initialValue.slice(0, initialPosition), after = initialValue.slice(initialPosition);\n    if (updatedValue.startsWith(before))\n      return initialPosition;\n    if (updatedValue.endsWith(after))\n      return updatedValue.length - after.length;\n    {\n      let relevantChars = stripSpacesAndPunctuation(before).length, pos = 0, relevantIndex = 0;\n      for (; relevantIndex < relevantChars; )\n        stripSpacesAndPunctuation(updatedValue[pos]) && relevantIndex++, pos++;\n      return pos;\n    }\n  }\n  return -1;\n}\nfunction stripSpacesAndPunctuation(str) {\n  return str.replace(/[^\\p{L}\\p{N}]/gu, \"\");\n}\n\n// src/common/meta.ts\nvar DEFAULT_RUNTIME_ID = \"M\", DEFAULT_RENDER_ID = \"_\";\n\n// src/dom/resume.ts\nvar registeredValues = {};\nfunction init(runtimeId = DEFAULT_RUNTIME_ID) {\n  let renders = window[runtimeId], defineRuntime = (desc) => Object.defineProperty(window, runtimeId, desc), resumeRender, initRuntime = (renders2) => {\n    defineRuntime({\n      value: resumeRender = (renderId) => {\n        let render = resumeRender[renderId] = renders2[renderId] || renders2(renderId), walk2 = render.w, commentPrefixLen = render.i.length, branchStack = [], scopeLookup = render.s = {}, serializeContext = {\n          _: registeredValues\n        }, branchIds = /* @__PURE__ */ new Set(), parentBranchIds = /* @__PURE__ */ new Map(), currentBranchId, $global, lastScopeId = 0;\n        return render.w = () => {\n          walk2.call(render);\n          let visits = render.v, resumes = render.r;\n          if (visits.length) {\n            let visitNodes = new Set(visits), lastEndNode;\n            visits.length = 0;\n            let branchEnd = (branchId, reference) => {\n              let branch = scopeLookup[branchId] ||= {}, endNode = reference;\n              for (; endNode.previousSibling !== branch.h && visitNodes.has(endNode = endNode.previousSibling); ) ;\n              return endNode === lastEndNode && (endNode = reference.parentNode.insertBefore(\n                new Text(),\n                reference\n              )), branch.j = lastEndNode = endNode, branch.h ||= endNode, branchIds.add(branchId), branch;\n            };\n            for (let visit of visitNodes) {\n              let commentText = visit.data, dataIndex = commentText.indexOf(\" \") + 1, scopeId = +commentText.slice(\n                commentPrefixLen + 1,\n                dataIndex ? dataIndex - 1 : commentText.length\n              ), scope = scopeLookup[scopeId] ||= {\n                m: scopeId\n              }, data2 = dataIndex ? commentText.slice(dataIndex) : \"\", token = commentText[commentPrefixLen];\n              if (token === \"*\" /* Node */) {\n                let node = scope[data2] = visit.previousSibling;\n                scope[\"j\" /* Getter */ + data2] = () => node;\n              } else if (token === \"[\" /* BranchStart */)\n                currentBranchId && dataIndex && (branchEnd(currentBranchId, visit), currentBranchId = branchStack.pop()), currentBranchId && (branchStack.push(currentBranchId), parentBranchIds.set(scopeId, currentBranchId)), currentBranchId = scopeId, scope.h = visit;\n              else if (token === \"]\" /* BranchEnd */) {\n                scope[data2] = visit;\n                let curParent = visit.parentNode, startNode = branchEnd(\n                  currentBranchId,\n                  visit\n                ).h;\n                curParent !== startNode.parentNode && curParent.prepend(startNode), currentBranchId = branchStack.pop();\n              } else if (token === \"|\" /* BranchSingleNode */ || token === \"=\" /* BranchSingleNodeOnlyChildInParent */) {\n                let next = data2.indexOf(\" \"), curNode = visit;\n                for (scope[~next ? data2.slice(0, next) : data2] = token === \"=\" /* BranchSingleNodeOnlyChildInParent */ ? visit.parentNode : visit; ~next; ) {\n                  let start = next + 1;\n                  next = data2.indexOf(\" \", start);\n                  let childScopeId = +data2.slice(\n                    start,\n                    ~next ? next : data2.length\n                  );\n                  curNode = branchEnd(childScopeId, curNode).j, parentBranchIds.set(childScopeId, scopeId);\n                }\n              }\n            }\n          }\n          if (resumes)\n            try {\n              render.r = [], isResuming = 1;\n              for (let i = 0; i < resumes.length; i++) {\n                let serialized = resumes[i];\n                if (typeof serialized == \"function\")\n                  for (let scope of serialized(serializeContext))\n                    if (!$global)\n                      $global = scope || {}, $global.runtimeId = runtimeId, $global.renderId = renderId, $global.o = 1e6;\n                    else if (typeof scope == \"number\")\n                      lastScopeId += scope;\n                    else {\n                      let scopeId = ++lastScopeId, prevScope = scopeLookup[scopeId];\n                      scope.$global = $global, scope.m = scopeId, prevScope !== scope && (scopeLookup[scopeId] = Object.assign(\n                        scope,\n                        prevScope\n                      ));\n                      let parentBranchId = scope.g || parentBranchIds.get(scopeId);\n                      if (parentBranchId && (scope.k = scopeLookup[parentBranchId]), branchIds.has(scopeId)) {\n                        let branch = scope, parentBranch = branch.k;\n                        scope.k = branch, parentBranch && (branch.t = parentBranch, (parentBranch.z ||= /* @__PURE__ */ new Set()).add(\n                          branch\n                        ));\n                      }\n                    }\n                else\n                  registeredValues[resumes[++i]](\n                    scopeLookup[serialized],\n                    scopeLookup[serialized]\n                  );\n              }\n            } finally {\n              isResuming = 0;\n            }\n        }, render;\n      }\n    });\n  };\n  if (renders) {\n    initRuntime(renders);\n    for (let renderId in renders)\n      resumeRender(renderId).w();\n  } else\n    defineRuntime({\n      configurable: !0,\n      set: initRuntime\n    });\n}\nvar isResuming;\nfunction register(id, obj) {\n  return registeredValues[id] = obj, obj;\n}\nfunction registerBoundSignal(id, signal) {\n  return registeredValues[id] = (scope) => (value2) => signal(scope, value2), signal;\n}\nfunction getRegisteredWithScope(id, scope) {\n  let val = registeredValues[id];\n  return scope ? val(scope) : val;\n}\nfunction nodeRef(id, key) {\n  return register(id, (scope) => () => scope[key]());\n}\n\n// src/dom/controllable.ts\nfunction controllable_input_checked(scope, nodeAccessor, checked, checkedChange) {\n  setCheckboxValue(\n    scope,\n    nodeAccessor,\n    0 /* InputChecked */,\n    normalizeBoolProp(checked),\n    checkedChange\n  );\n}\nfunction controllable_input_checked_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor];\n  syncControllable(el, \"input\", hasCheckboxChanged, () => {\n    let checkedChange = scope[\"e\" /* ControlledHandler */ + nodeAccessor];\n    if (checkedChange) {\n      let newValue = el.checked;\n      el.checked = !newValue, checkedChange(newValue), run();\n    }\n  });\n}\nfunction controllable_input_checkedValue(scope, nodeAccessor, checkedValue, checkedValueChange, value2) {\n  scope[\"g\" /* ControlledValue */ + nodeAccessor] = checkedValue, attr(scope[nodeAccessor], \"value\", value2), setCheckboxValue(\n    scope,\n    nodeAccessor,\n    1 /* InputCheckedValue */,\n    Array.isArray(checkedValue) ? checkedValue.includes(value2) : checkedValue === value2,\n    checkedValueChange\n  );\n}\nfunction controllable_input_checkedValue_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor];\n  syncControllable(el, \"input\", hasCheckboxChanged, () => {\n    let checkedValueChange = scope[\"e\" /* ControlledHandler */ + nodeAccessor];\n    if (checkedValueChange) {\n      let oldValue = scope[\"g\" /* ControlledValue */ + nodeAccessor], newValue = Array.isArray(oldValue) ? updateList(oldValue, el.value, el.checked) : el.checked ? el.value : void 0;\n      if (el.name && el.type[0] === \"r\")\n        for (let radio of el.getRootNode().querySelectorAll(\n          `[type=radio][name=${CSS.escape(el.name)}]`\n        ))\n          radio.form === el.form && (radio.checked = Array.isArray(oldValue) ? oldValue.includes(radio.value) : oldValue === radio.value);\n      else\n        el.checked = !el.checked;\n      checkedValueChange(newValue), run();\n    }\n  });\n}\nfunction controllable_input_value(scope, nodeAccessor, value2, valueChange) {\n  let el = scope[nodeAccessor], normalizedValue = normalizeStrProp(value2);\n  scope[\"e\" /* ControlledHandler */ + nodeAccessor] = valueChange, valueChange ? (scope[\"f\" /* ControlledType */ + nodeAccessor] = 0 /* InputChecked */, scope[\"g\" /* ControlledValue */ + nodeAccessor] = value2, el.isConnected ? setValueAndUpdateSelection(el, normalizedValue) : el.defaultValue = normalizedValue) : (scope[\"f\" /* ControlledType */ + nodeAccessor] = 5 /* None */, el.defaultValue = normalizedValue);\n}\nfunction controllable_input_value_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor];\n  isResuming && (scope[\"g\" /* ControlledValue */ + nodeAccessor] = el.defaultValue), syncControllable(el, \"input\", hasValueChanged, (ev) => {\n    let valueChange = scope[\"e\" /* ControlledHandler */ + nodeAccessor];\n    valueChange && (inputType = ev?.inputType, valueChange(el.value), run(), setValueAndUpdateSelection(\n      el,\n      scope[\"g\" /* ControlledValue */ + nodeAccessor]\n    ), inputType = \"\");\n  });\n}\nfunction controllable_select_value(scope, nodeAccessor, value2, valueChange) {\n  scope[\"e\" /* ControlledHandler */ + nodeAccessor] = valueChange, valueChange ? (scope[\"f\" /* ControlledType */ + nodeAccessor] = 3 /* SelectValue */, scope[\"g\" /* ControlledValue */ + nodeAccessor] = value2) : scope[\"f\" /* ControlledType */ + nodeAccessor] = 5 /* None */, pendingEffects.unshift(\n    () => setSelectOptions(\n      scope[nodeAccessor],\n      value2,\n      valueChange\n    ),\n    scope\n  );\n}\nfunction controllable_select_value_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor], onChange = () => {\n    let valueChange = scope[\"e\" /* ControlledHandler */ + nodeAccessor];\n    if (valueChange) {\n      let newValue = Array.isArray(\n        scope[\"g\" /* ControlledValue */ + nodeAccessor]\n      ) ? Array.from(el.selectedOptions, toValueProp) : el.value;\n      setSelectOptions(\n        el,\n        scope[\"g\" /* ControlledValue */ + nodeAccessor],\n        valueChange\n      ), valueChange(newValue), run();\n    }\n  };\n  el._ || new MutationObserver(() => {\n    let value2 = scope[\"g\" /* ControlledValue */ + nodeAccessor];\n    (Array.isArray(value2) ? value2.length !== el.selectedOptions.length || value2.some((value3, i) => value3 != el.selectedOptions[i].value) : el.value != value2) && onChange();\n  }).observe(el, {\n    childList: !0,\n    subtree: !0\n  }), syncControllable(el, \"input\", hasSelectChanged, onChange);\n}\nfunction setSelectOptions(el, value2, valueChange) {\n  if (Array.isArray(value2))\n    for (let opt of el.options) {\n      let selected = value2.includes(opt.value);\n      valueChange ? opt.selected = selected : opt.defaultSelected = selected;\n    }\n  else {\n    let normalizedValue = normalizeStrProp(value2);\n    if (valueChange)\n      el.value = normalizedValue;\n    else\n      for (let opt of el.options)\n        opt.defaultSelected = opt.value === normalizedValue;\n  }\n}\nfunction controllable_detailsOrDialog_open(scope, nodeAccessor, open, openChange) {\n  scope[\"e\" /* ControlledHandler */ + nodeAccessor] = openChange, openChange ? scope[\"f\" /* ControlledType */ + nodeAccessor] = 4 /* DetailsOrDialogOpen */ : scope[\"f\" /* ControlledType */ + nodeAccessor] = 5 /* None */, scope[nodeAccessor].open = scope[\"g\" /* ControlledValue */ + nodeAccessor] = normalizeBoolProp(open);\n}\nfunction controllable_detailsOrDialog_open_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor], hasChanged = () => el.open !== scope[\"g\" /* ControlledValue */ + nodeAccessor];\n  syncControllable(\n    el,\n    el.tagName === \"DIALOG\" ? \"close\" : \"toggle\",\n    hasChanged,\n    () => {\n      let openChange = scope[\"e\" /* ControlledHandler */ + nodeAccessor];\n      if (openChange && hasChanged()) {\n        let newValue = el.open;\n        el.open = !newValue, openChange(newValue), run();\n      }\n    }\n  );\n}\nvar inputType = \"\";\nfunction setValueAndUpdateSelection(el, value2) {\n  if (el.value !== value2) {\n    let updatedPosition = resolveCursorPosition(\n      inputType,\n      el.getRootNode().activeElement === el && el.selectionStart,\n      el.value,\n      el.value = value2\n    );\n    ~updatedPosition && el.setSelectionRange(updatedPosition, updatedPosition);\n  }\n}\nfunction setCheckboxValue(scope, nodeAccessor, type, checked, checkedChange) {\n  scope[\"e\" /* ControlledHandler */ + nodeAccessor] = checkedChange, checkedChange ? (scope[\"f\" /* ControlledType */ + nodeAccessor] = type, scope[nodeAccessor].checked = checked) : (scope[\"f\" /* ControlledType */ + nodeAccessor] = 5 /* None */, scope[nodeAccessor].defaultChecked = checked);\n}\nvar controllableDelegate = createDelegator();\nfunction syncControllable(el, event, hasChanged, onChange) {\n  el._ || (controllableDelegate(el, event, handleChange), el.form && controllableDelegate(el.form, \"reset\", handleFormReset), isResuming && hasChanged(el) && queueMicrotask(onChange)), el._ = onChange;\n}\nfunction handleChange(ev) {\n  ev.target._?.(ev);\n}\nfunction handleFormReset(ev) {\n  let handlers = [];\n  for (let el of ev.target.elements)\n    el._ && hasFormElementChanged(el) && handlers.push(el._);\n  requestAnimationFrame(() => {\n    if (!ev.defaultPrevented)\n      for (let change of handlers)\n        change();\n  });\n}\nfunction hasValueChanged(el) {\n  return el.value !== el.defaultValue;\n}\nfunction hasCheckboxChanged(el) {\n  return el.checked !== el.defaultChecked;\n}\nfunction hasSelectChanged(el) {\n  for (let opt of el.options)\n    if (opt.selected !== opt.defaultSelected)\n      return !0;\n}\nfunction hasFormElementChanged(el) {\n  return el.options ? hasSelectChanged(el) : hasValueChanged(el) || hasCheckboxChanged(el);\n}\nfunction normalizeStrProp(value2) {\n  return normalizeAttrValue(value2) || \"\";\n}\nfunction normalizeBoolProp(value2) {\n  return value2 != null && value2 !== !1;\n}\nfunction updateList(arr, val, push) {\n  let index = arr.indexOf(val);\n  return (push ? !~index && [...arr, val] : ~index && arr.slice(0, index).concat(arr.slice(index + 1))) || arr;\n}\nfunction toValueProp(it) {\n  return it.value;\n}\n\n// src/dom/parse-html.ts\nvar parsers = {};\nfunction parseHTML(html2, ns) {\n  let parser = parsers[ns] ||= document.createElementNS(ns, \"template\");\n  return parser.innerHTML = html2, parser.content || parser;\n}\n\n// src/dom/dom.ts\nfunction attr(element, name, value2) {\n  setAttribute(element, name, normalizeAttrValue(value2));\n}\nfunction setAttribute(element, name, value2) {\n  element.getAttribute(name) != value2 && (value2 === void 0 ? element.removeAttribute(name) : element.setAttribute(name, value2));\n}\nfunction classAttr(element, value2) {\n  setAttribute(element, \"class\", classValue(value2) || void 0);\n}\nfunction styleAttr(element, value2) {\n  setAttribute(element, \"style\", styleValue(value2) || void 0);\n}\nfunction data(node, value2) {\n  let normalizedValue = normalizeString(value2);\n  node.data !== normalizedValue && (node.data = normalizedValue);\n}\nfunction textContent(node, value2) {\n  let normalizedValue = normalizeString(value2);\n  node.textContent !== normalizedValue && (node.textContent = normalizedValue);\n}\nfunction attrs(scope, nodeAccessor, nextAttrs) {\n  let el = scope[nodeAccessor];\n  for (let i = el.attributes.length; i--; ) {\n    let { name } = el.attributes.item(i);\n    nextAttrs && (name in nextAttrs || hasAttrAlias(el, name, nextAttrs)) || el.removeAttribute(name);\n  }\n  attrsInternal(scope, nodeAccessor, nextAttrs);\n}\nfunction hasAttrAlias(element, attr2, nextAttrs) {\n  return attr2 === \"checked\" && element.tagName === \"INPUT\" && \"checkedValue\" in nextAttrs;\n}\nfunction partialAttrs(scope, nodeAccessor, nextAttrs, skip) {\n  let el = scope[nodeAccessor], partial = {};\n  for (let i = el.attributes.length; i--; ) {\n    let { name } = el.attributes.item(i);\n    !skip[name] && !(nextAttrs && name in nextAttrs) && el.removeAttribute(name);\n  }\n  for (let key in nextAttrs)\n    skip[key] || (partial[key] = nextAttrs[key]);\n  attrsInternal(scope, nodeAccessor, partial);\n}\nfunction attrsInternal(scope, nodeAccessor, nextAttrs) {\n  let el = scope[nodeAccessor], events, skip;\n  switch (el.tagName) {\n    case \"INPUT\":\n      if (\"checked\" in nextAttrs || \"checkedChange\" in nextAttrs)\n        controllable_input_checked(\n          scope,\n          nodeAccessor,\n          nextAttrs.checked,\n          nextAttrs.checkedChange\n        );\n      else if (\"checkedValue\" in nextAttrs || \"checkedValueChange\" in nextAttrs)\n        controllable_input_checkedValue(\n          scope,\n          nodeAccessor,\n          nextAttrs.checkedValue,\n          nextAttrs.checkedValueChange,\n          nextAttrs.value\n        );\n      else if (\"value\" in nextAttrs || \"valueChange\" in nextAttrs)\n        controllable_input_value(\n          scope,\n          nodeAccessor,\n          nextAttrs.value,\n          nextAttrs.valueChange\n        );\n      else\n        break;\n      skip = /^(?:value|checked(?:Value)?)(?:Change)?$/;\n      break;\n    case \"SELECT\":\n      (\"value\" in nextAttrs || \"valueChange\" in nextAttrs) && (controllable_select_value(\n        scope,\n        nodeAccessor,\n        nextAttrs.value,\n        nextAttrs.valueChange\n      ), skip = /^value(?:Change)?$/);\n      break;\n    case \"TEXTAREA\":\n      (\"value\" in nextAttrs || \"valueChange\" in nextAttrs) && (controllable_input_value(\n        scope,\n        nodeAccessor,\n        nextAttrs.value,\n        nextAttrs.valueChange\n      ), skip = /^value(?:Change)?$/);\n      break;\n    case \"DETAILS\":\n    case \"DIALOG\":\n      (\"open\" in nextAttrs || \"openChange\" in nextAttrs) && (controllable_detailsOrDialog_open(\n        scope,\n        nodeAccessor,\n        nextAttrs.open,\n        nextAttrs.openChange\n      ), skip = /^open(?:Change)?$/);\n      break;\n  }\n  for (let name in nextAttrs) {\n    let value2 = nextAttrs[name];\n    switch (name) {\n      case \"class\":\n        classAttr(el, value2);\n        break;\n      case \"style\":\n        styleAttr(el, value2);\n        break;\n      case \"content\":\n        break;\n      default:\n        isEventHandler(name) ? (events ||= scope[\"i\" /* EventAttributes */ + nodeAccessor] = {})[getEventHandlerName(name)] = value2 : skip?.test(name) || attr(el, name, value2);\n    }\n  }\n}\nfunction attrsEvents(scope, nodeAccessor) {\n  let el = scope[nodeAccessor], events = scope[\"i\" /* EventAttributes */ + nodeAccessor];\n  switch (scope[\"f\" /* ControlledType */ + nodeAccessor]) {\n    case 0 /* InputChecked */:\n      controllable_input_checked_effect(scope, nodeAccessor);\n      break;\n    case 1 /* InputCheckedValue */:\n      controllable_input_checkedValue_effect(scope, nodeAccessor);\n      break;\n    case 2 /* InputValue */:\n      controllable_input_value_effect(scope, nodeAccessor);\n      break;\n    case 3 /* SelectValue */:\n      controllable_select_value_effect(scope, nodeAccessor);\n      break;\n    case 4 /* DetailsOrDialogOpen */:\n      controllable_detailsOrDialog_open_effect(scope, nodeAccessor);\n      break;\n  }\n  for (let name in events)\n    on(el, name, events[name]);\n}\nfunction html(scope, value2, accessor) {\n  let firstChild = scope[accessor], parentNode = firstChild.parentNode, lastChild = scope[\"h\" /* DynamicPlaceholderLastChild */ + accessor] || firstChild, newContent = parseHTML(\n    value2 || value2 === 0 ? value2 + \"\" : \"\",\n    parentNode.namespaceURI\n  );\n  insertChildNodes(\n    parentNode,\n    firstChild,\n    scope[accessor] = newContent.firstChild || newContent.appendChild(new Text()),\n    scope[\"h\" /* DynamicPlaceholderLastChild */ + accessor] = newContent.lastChild\n  ), removeChildNodes(firstChild, lastChild);\n}\nfunction props(scope, nodeIndex, index) {\n  let nextProps = scope[index], prevProps = scope[index + \"-\"], node = scope[nodeIndex];\n  if (prevProps)\n    for (let name in prevProps)\n      name in nextProps || (node[name] = void 0);\n  for (let name in nextProps)\n    node[name] = nextProps[name];\n  scope[index + \"-\"] = nextProps;\n}\nfunction normalizeAttrValue(value2) {\n  if (value2 || value2 === 0)\n    return value2 === !0 ? \"\" : value2 + \"\";\n}\nfunction normalizeString(value2) {\n  return value2 || value2 === 0 ? value2 + \"\" : \"\\u200D\";\n}\nfunction lifecycle(scope, index, thisObj) {\n  let instance = scope[index];\n  instance ? (Object.assign(instance, thisObj), instance.onUpdate?.()) : (scope[index] = thisObj, thisObj.onMount?.(), getAbortSignal(\n    scope,\n    \"k\" /* LifecycleAbortController */ + index\n  ).onabort = () => thisObj.onDestroy?.());\n}\nfunction removeChildNodes(startNode, endNode) {\n  let stop = endNode.nextSibling, current = startNode;\n  for (; current !== stop; ) {\n    let next = current.nextSibling;\n    current.remove(), current = next;\n  }\n}\nfunction insertChildNodes(parentNode, referenceNode, startNode, endNode) {\n  parentNode.insertBefore(toInsertNode(startNode, endNode), referenceNode);\n}\nfunction toInsertNode(startNode, endNode) {\n  if (startNode === endNode) return startNode;\n  let parent = new DocumentFragment(), stop = endNode.nextSibling, current = startNode;\n  for (; current !== stop; ) {\n    let next = current.nextSibling;\n    parent.appendChild(current), current = next;\n  }\n  return parent;\n}\n\n// src/dom/scope.ts\nvar pendingScopes = [];\nfunction createScope($global, closestBranch) {\n  let scope = {\n    m: $global.o++,\n    p: 1,\n    k: closestBranch,\n    $global\n  };\n  return pendingScopes.push(scope), scope;\n}\nfunction skipScope(scope) {\n  return scope.$global.o++;\n}\nfunction finishPendingScopes() {\n  for (let scope of pendingScopes)\n    scope.p = 0;\n  pendingScopes = [];\n}\nfunction findBranchWithKey(scope, key) {\n  let branch = scope.k;\n  for (; branch && !branch[key]; )\n    branch = branch.t;\n  return branch;\n}\nfunction destroyBranch(branch) {\n  branch.t?.z?.delete(branch), destroyNestedBranches(branch);\n}\nfunction destroyNestedBranches(branch) {\n  branch.A = 1, branch.z?.forEach(destroyNestedBranches), branch.J?.forEach((scope) => {\n    for (let id in scope.u)\n      scope.u[id]?.abort();\n  });\n}\nfunction removeAndDestroyBranch(branch) {\n  destroyBranch(branch), removeChildNodes(branch.h, branch.j);\n}\nfunction insertBranchBefore(branch, parentNode, nextSibling) {\n  insertChildNodes(\n    parentNode,\n    nextSibling,\n    branch.h,\n    branch.j\n  );\n}\nfunction tempDetachBranch(branch) {\n  let fragment = new DocumentFragment();\n  fragment.namespaceURI = branch.h.parentNode.namespaceURI, insertChildNodes(fragment, null, branch.h, branch.j);\n}\n\n// src/dom/reconcile.ts\nvar WRONG_POS = 2147483647;\nfunction reconcile(parent, oldBranches, newBranches, afterReference) {\n  let oldStart = 0, newStart = 0, oldEnd = oldBranches.length - 1, newEnd = newBranches.length - 1, oldStartBranch = oldBranches[oldStart], newStartBranch = newBranches[newStart], oldEndBranch = oldBranches[oldEnd], newEndBranch = newBranches[newEnd], i, j, k, nextSibling, oldBranch, newBranch;\n  outer: {\n    for (; oldStartBranch === newStartBranch; ) {\n      if (++oldStart, ++newStart, oldStart > oldEnd || newStart > newEnd)\n        break outer;\n      oldStartBranch = oldBranches[oldStart], newStartBranch = newBranches[newStart];\n    }\n    for (; oldEndBranch === newEndBranch; ) {\n      if (--oldEnd, --newEnd, oldStart > oldEnd || newStart > newEnd)\n        break outer;\n      oldEndBranch = oldBranches[oldEnd], newEndBranch = newBranches[newEnd];\n    }\n  }\n  if (oldStart > oldEnd) {\n    if (newStart <= newEnd) {\n      k = newEnd + 1, nextSibling = k < newBranches.length ? newBranches[k].h : afterReference;\n      do\n        insertBranchBefore(newBranches[newStart++], parent, nextSibling);\n      while (newStart <= newEnd);\n    }\n  } else if (newStart > newEnd)\n    do\n      removeAndDestroyBranch(oldBranches[oldStart++]);\n    while (oldStart <= oldEnd);\n  else {\n    let oldLength = oldEnd - oldStart + 1, newLength = newEnd - newStart + 1, aNullable = oldBranches, sources = new Array(newLength);\n    for (i = 0; i < newLength; ++i)\n      sources[i] = -1;\n    let pos = 0, synced = 0, keyIndex = /* @__PURE__ */ new Map();\n    for (j = newStart; j <= newEnd; ++j)\n      keyIndex.set(newBranches[j], j);\n    for (i = oldStart; i <= oldEnd && synced < newLength; ++i)\n      oldBranch = oldBranches[i], j = keyIndex.get(oldBranch), j !== void 0 && (pos = pos > j ? WRONG_POS : j, ++synced, newBranch = newBranches[j], sources[j - newStart] = i, aNullable[i] = null);\n    if (oldLength === oldBranches.length && synced === 0) {\n      for (; newStart < newLength; ++newStart)\n        insertBranchBefore(newBranches[newStart], parent, afterReference);\n      for (; oldStart < oldLength; ++oldStart)\n        removeAndDestroyBranch(oldBranches[oldStart]);\n    } else {\n      for (i = oldLength - synced; i > 0; )\n        oldBranch = aNullable[oldStart++], oldBranch !== null && (removeAndDestroyBranch(oldBranch), i--);\n      if (pos === WRONG_POS) {\n        let seq = longestIncreasingSubsequence(sources);\n        for (j = seq.length - 1, k = newBranches.length, i = newLength - 1; i >= 0; --i)\n          sources[i] === -1 ? (pos = i + newStart, newBranch = newBranches[pos++], nextSibling = pos < k ? newBranches[pos].h : afterReference, insertBranchBefore(newBranch, parent, nextSibling)) : j < 0 || i !== seq[j] ? (pos = i + newStart, newBranch = newBranches[pos++], nextSibling = pos < k ? newBranches[pos].h : afterReference, insertBranchBefore(newBranch, parent, nextSibling)) : --j;\n      } else if (synced !== newLength)\n        for (k = newBranches.length, i = newLength - 1; i >= 0; --i)\n          sources[i] === -1 && (pos = i + newStart, newBranch = newBranches[pos++], nextSibling = pos < k ? newBranches[pos].h : afterReference, insertBranchBefore(newBranch, parent, nextSibling));\n    }\n  }\n}\nfunction longestIncreasingSubsequence(a) {\n  let p = a.slice(), result = [0], u, v;\n  for (let i = 0, il = a.length; i < il; ++i) {\n    if (a[i] === -1)\n      continue;\n    let j = result[result.length - 1];\n    if (a[j] < a[i]) {\n      p[i] = j, result.push(i);\n      continue;\n    }\n    for (u = 0, v = result.length - 1; u < v; ) {\n      let c = (u + v) / 2 | 0;\n      a[result[c]] < a[i] ? u = c + 1 : v = c;\n    }\n    a[i] < a[result[u]] && (u > 0 && (p[i] = result[u - 1]), result[u] = i);\n  }\n  for (u = result.length, v = result[u - 1]; u-- > 0; )\n    result[u] = v, v = p[v];\n  return result;\n}\n\n// src/dom/walker.ts\nvar walker = /* @__PURE__ */ document.createTreeWalker(document);\nfunction walk(startNode, walkCodes, branch) {\n  walker.currentNode = startNode, walkInternal(0, walkCodes, branch);\n}\nfunction walkInternal(currentWalkIndex, walkCodes, scope) {\n  let value2, storedMultiplier = 0, currentMultiplier = 0, currentScopeIndex = 0;\n  for (; currentWalkIndex < walkCodes.length; )\n    if (value2 = walkCodes.charCodeAt(currentWalkIndex++), currentMultiplier = storedMultiplier, storedMultiplier = 0, value2 === 32 /* Get */) {\n      let node = walker.currentNode;\n      scope[currentScopeIndex] = node, scope[\"j\" /* Getter */ + currentScopeIndex++] = () => node;\n    } else if (value2 === 37 /* Replace */ || value2 === 49 /* DynamicTagWithVar */)\n      walker.currentNode.replaceWith(\n        walker.currentNode = scope[currentScopeIndex++] = new Text()\n      ), value2 === 49 /* DynamicTagWithVar */ && (scope[currentScopeIndex++] = skipScope(scope));\n    else {\n      if (value2 === 38 /* EndChild */)\n        return currentWalkIndex;\n      if (value2 === 47 /* BeginChild */ || value2 === 48 /* BeginChildWithVar */)\n        currentWalkIndex = walkInternal(\n          currentWalkIndex,\n          walkCodes,\n          scope[currentScopeIndex++] = createScope(scope.$global, scope.k)\n        ), value2 === 48 /* BeginChildWithVar */ && (scope[currentScopeIndex++] = skipScope(scope));\n      else if (value2 < 92)\n        for (value2 = 20 /* Next */ * currentMultiplier + value2 - 67 /* Next */; value2--; )\n          walker.nextNode();\n      else if (value2 < 107)\n        for (value2 = 10 /* Over */ * currentMultiplier + value2 - 97 /* Over */; value2--; )\n          walker.nextSibling();\n      else if (value2 < 117) {\n        for (value2 = 10 /* Out */ * currentMultiplier + value2 - 107 /* Out */; value2--; )\n          walker.parentNode();\n        walker.nextSibling();\n      } else\n        storedMultiplier = currentMultiplier * 10 /* Multiplier */ + value2 - 117 /* Multiplier */;\n    }\n}\n\n// src/dom/renderer.ts\nfunction createBranch($global, renderer, parentScope, parentNode) {\n  let branch = createScope($global), parentBranch = parentScope?.k;\n  return branch._ = renderer.x || parentScope, branch.k = branch, parentBranch && (branch.t = parentBranch, (parentBranch.z ||= /* @__PURE__ */ new Set()).add(branch)), renderer.B?.(\n    branch,\n    parentNode.namespaceURI\n  ), branch;\n}\nfunction createAndSetupBranch($global, renderer, parentScope, parentNode) {\n  return setupBranch(\n    renderer,\n    createBranch($global, renderer, parentScope, parentNode)\n  );\n}\nfunction setupBranch(renderer, branch) {\n  return (renderer.C || renderer.E) && queueRender(\n    branch,\n    (branch2) => {\n      renderer.C?.(branch2), renderer.E?.(branch2);\n    },\n    -1\n  ), branch;\n}\nfunction createContent(id, template, walks, setup, params, closures, dynamicScopesAccessor) {\n  walks = walks ? walks.replace(/[^\\0-1]+$/, \"\") : \"\", setup ||= void 0, params ||= void 0, closures ||= void 0;\n  let clone = template ? (branch, ns) => {\n    ((cloneCache[ns] ||= {})[template] ||= createCloneableHTML(\n      template,\n      ns\n    ))(branch, walks);\n  } : (branch) => {\n    walk(\n      branch.h = branch.j = new Text(),\n      walks,\n      branch\n    );\n  };\n  return (owner) => ({\n    m: id,\n    B: clone,\n    x: owner,\n    C: setup,\n    l: params,\n    E: closures,\n    y: dynamicScopesAccessor\n  });\n}\nfunction registerContent(id, template, walks, setup, params, closures, dynamicScopesAccessor) {\n  return register(\n    id,\n    createContent(\n      id,\n      template,\n      walks,\n      setup,\n      params,\n      closures,\n      dynamicScopesAccessor\n    )\n  );\n}\nfunction createRenderer(template, walks, setup, params, closures) {\n  return createContent(\"\", template, walks, setup, params, closures)();\n}\nvar cloneCache = {};\nfunction createCloneableHTML(html2, ns) {\n  let { firstChild, lastChild } = parseHTML(html2, ns), parent = document.createElementNS(ns, \"t\");\n  return insertChildNodes(parent, null, firstChild, lastChild), firstChild === lastChild && firstChild.nodeType < 8 /* Comment */ ? (branch, walks) => {\n    walk(\n      branch.h = branch.j = firstChild.cloneNode(!0),\n      walks,\n      branch\n    );\n  } : (branch, walks) => {\n    let clone = parent.cloneNode(!0);\n    walk(clone.firstChild, walks, branch), branch.h = clone.firstChild, branch.j = clone.lastChild;\n  };\n}\n\n// src/dom/schedule.ts\nvar port2 = /* @__PURE__ */ (() => {\n  let { port1, port2: port22 } = new MessageChannel();\n  return port1.onmessage = () => {\n    isScheduled = 0, run();\n  }, port22;\n})(), isScheduled;\nfunction schedule() {\n  isScheduled || (isScheduled = 1, queueMicrotask(flushAndWaitFrame));\n}\nfunction flushAndWaitFrame() {\n  run(), requestAnimationFrame(triggerMacroTask);\n}\nfunction triggerMacroTask() {\n  port2.postMessage(0);\n}\n\n// src/dom/signals.ts\nfunction state(valueAccessor, fn) {\n  if (0)\n    var id;\n  let valueChangeAccessor = \"o\" /* TagVariableChange */ + valueAccessor, update = (scope, value2) => {\n    scope[valueAccessor] !== value2 && (scope[valueAccessor] = value2, fn(scope, value2));\n  };\n  return (scope, value2, valueChange) => (rendering ? ((scope[valueChangeAccessor] = valueChange) && scope[valueAccessor] !== value2 || !(valueAccessor in scope)) && (scope[valueAccessor] = value2, fn(scope, value2)) : scope[valueChangeAccessor] ? scope[valueChangeAccessor](value2) : (schedule(), queueRender(\n    scope,\n    update,\n    valueAccessor,\n    value2\n  )), value2);\n}\nfunction value(valueAccessor, fn = () => {\n}) {\n  return (scope, value2) => {\n    (!(valueAccessor in scope) || scope[valueAccessor] !== value2) && (scope[valueAccessor] = value2, fn(scope, value2));\n  };\n}\nfunction intersection(id, fn, defaultPending = 1, scopeIdAccessor = /* @__KEY__ */ \"m\") {\n  return (scope) => {\n    scope.p ? scope[id] === void 0 ? scope[id] = defaultPending : --scope[id] || fn(scope) : queueRender(scope, fn, id, 0, scope[scopeIdAccessor]);\n  };\n}\nfunction loopClosure(valueAccessor, ownerLoopNodeAccessor, fn) {\n  let childSignal = closure(valueAccessor, fn), loopScopeAccessor = \"l\" /* LoopScopeArray */ + ownerLoopNodeAccessor, loopScopeMapAccessor = \"m\" /* LoopScopeMap */ + ownerLoopNodeAccessor, ownerSignal = (ownerScope) => {\n    let scopes = ownerScope[loopScopeAccessor] || ownerScope[loopScopeMapAccessor]?.values() || [], [firstScope] = scopes;\n    firstScope && queueRender(\n      ownerScope,\n      () => {\n        for (let scope of scopes)\n          !scope.p && !scope.A && childSignal(scope);\n      },\n      -1,\n      0,\n      firstScope.m\n    );\n  };\n  return ownerSignal._ = childSignal, ownerSignal;\n}\nfunction conditionalClosure(valueAccessor, ownerConditionalNodeAccessor, branch, fn) {\n  let childSignal = closure(valueAccessor, fn), scopeAccessor = \"d\" /* ConditionalScope */ + ownerConditionalNodeAccessor, branchAccessor = \"c\" /* ConditionalRenderer */ + ownerConditionalNodeAccessor, ownerSignal = (scope) => {\n    let ifScope = scope[scopeAccessor];\n    ifScope && !ifScope.p && scope[branchAccessor] === branch && queueRender(ifScope, childSignal, -1);\n  };\n  return ownerSignal._ = childSignal, ownerSignal;\n}\nfunction subscribeToScopeSet(ownerScope, accessor, scope) {\n  let subscribers = ownerScope[accessor] ||= /* @__PURE__ */ new Set();\n  subscribers.has(scope) || (subscribers.add(scope), getAbortSignal(scope, -1).addEventListener(\n    \"abort\",\n    () => ownerScope[accessor].delete(scope)\n  ));\n}\nfunction dynamicClosure(...closureSignals) {\n  let [{ F: ___scopeInstancesAccessor, G: ___signalIndexAccessor }] = closureSignals;\n  for (let i = closureSignals.length; i--; )\n    closureSignals[i].K = i;\n  return (scope) => {\n    if (scope[___scopeInstancesAccessor])\n      for (let childScope of scope[___scopeInstancesAccessor])\n        childScope.p || queueRender(\n          childScope,\n          closureSignals[childScope[___signalIndexAccessor]],\n          -1\n        );\n  };\n}\nfunction dynamicClosureRead(valueAccessor, fn, getOwnerScope) {\n  let childSignal = closure(valueAccessor, fn, getOwnerScope), closureSignal = (scope) => {\n    scope[closureSignal.G] = closureSignal.K, childSignal(scope), subscribeToScopeSet(\n      getOwnerScope ? getOwnerScope(scope) : scope._,\n      closureSignal.F,\n      scope\n    );\n  };\n  return closureSignal.F = \"a\" /* ClosureScopes */ + valueAccessor, closureSignal.G = \"b\" /* ClosureSignalIndex */ + valueAccessor, closureSignal;\n}\nfunction closure(valueAccessor, fn, getOwnerScope) {\n  return (scope) => {\n    fn(\n      scope,\n      (getOwnerScope ? getOwnerScope(scope) : scope._)[valueAccessor]\n    );\n  };\n}\nfunction setTagVar(scope, childAccessor, tagVarSignal2) {\n  scope[childAccessor].e = (value2) => tagVarSignal2(scope, value2);\n}\nvar tagVarSignal = (scope, value2) => scope.e?.(value2);\nfunction setTagVarChange(scope, changeHandler) {\n  scope.f = changeHandler;\n}\nvar tagVarSignalChange = (scope, value2) => scope.f?.(value2), tagIdsByGlobal = /* @__PURE__ */ new WeakMap();\nfunction nextTagId({ $global }) {\n  let id = tagIdsByGlobal.get($global) || 0;\n  return tagIdsByGlobal.set($global, id + 1), \"c\" + $global.runtimeId + $global.renderId + id.toString(36);\n}\nfunction effect(id, fn) {\n  return register(id, fn), (scope) => {\n    queueEffect(scope, fn);\n  };\n}\nfunction* traverseAllHoisted(scope, path, curIndex = path.length - 1) {\n  if (scope)\n    if (Symbol.iterator in scope)\n      for (let s of scope instanceof Map ? scope.values() : scope)\n        yield* traverseAllHoisted(s, path, curIndex);\n    else curIndex ? yield* traverseAllHoisted(scope[path[curIndex]], path, curIndex - 1) : yield scope[path[0]];\n}\nfunction hoist(...path) {\n  return (scope) => {\n    let getOne = (...args) => iterator().next().value(...args), iterator = getOne[Symbol.iterator] = () => traverseAllHoisted(scope, path);\n    return getOne;\n  };\n}\n\n// src/dom/control-flow.ts\nfunction awaitTag(nodeAccessor, renderer) {\n  let promiseAccessor = \"n\" /* Promise */ + nodeAccessor, branchAccessor = \"d\" /* ConditionalScope */ + nodeAccessor;\n  return (scope, promise) => {\n    let referenceNode = scope[nodeAccessor], tryWithPlaceholder = findBranchWithKey(\n      scope,\n      \"d\" /* PlaceholderContent */\n    ), awaitBranch = scope[branchAccessor];\n    tryWithPlaceholder ? (placeholderShown.add(pendingEffects), !scope[promiseAccessor] && (tryWithPlaceholder.n = (tryWithPlaceholder.n || 0) + 1) === 1 && requestAnimationFrame(\n      () => tryWithPlaceholder.n && runEffects(\n        prepareEffects(\n          () => queueRender(\n            tryWithPlaceholder,\n            () => {\n              insertBranchBefore(\n                tryWithPlaceholder.c = createAndSetupBranch(\n                  scope.$global,\n                  tryWithPlaceholder.d,\n                  tryWithPlaceholder._,\n                  tryWithPlaceholder.h.parentNode\n                ),\n                tryWithPlaceholder.h.parentNode,\n                tryWithPlaceholder.h\n              ), tempDetachBranch(tryWithPlaceholder);\n            },\n            -1\n          )\n        )\n      )\n    )) : awaitBranch && !scope[promiseAccessor] && (awaitBranch.h.parentNode.insertBefore(\n      referenceNode,\n      awaitBranch.h\n    ), tempDetachBranch(awaitBranch));\n    let thisPromise = scope[promiseAccessor] = promise.then(\n      (data2) => {\n        thisPromise === scope[promiseAccessor] && (scope[promiseAccessor] = 0, schedule(), queueRender(\n          scope,\n          () => {\n            if (awaitBranch ? tryWithPlaceholder || referenceNode.replaceWith(\n              awaitBranch.h.parentNode\n            ) : (insertBranchBefore(\n              awaitBranch = scope[branchAccessor] = createAndSetupBranch(\n                scope.$global,\n                renderer,\n                scope,\n                referenceNode.parentNode\n              ),\n              referenceNode.parentNode,\n              referenceNode\n            ), referenceNode.remove()), renderer.l?.(awaitBranch, [data2]), tryWithPlaceholder && (placeholderShown.add(pendingEffects), !--tryWithPlaceholder.n)) {\n              let placeholderBranch = tryWithPlaceholder.c;\n              tryWithPlaceholder.c = 0, placeholderBranch && (placeholderBranch.h.parentNode.insertBefore(\n                tryWithPlaceholder.h.parentNode,\n                placeholderBranch.h\n              ), removeAndDestroyBranch(placeholderBranch)), tryWithPlaceholder.H && runEffects(tryWithPlaceholder.H, !0);\n            }\n          },\n          -1\n        ));\n      },\n      (error) => {\n        thisPromise === scope[promiseAccessor] && (tryWithPlaceholder && (tryWithPlaceholder.n = 0), scope[promiseAccessor] = 0, schedule(), queueRender(scope, renderCatch, -1, error));\n      }\n    );\n  };\n}\nfunction createTry(nodeAccessor, tryContent) {\n  let branchAccessor = \"d\" /* ConditionalScope */ + nodeAccessor;\n  return (scope, input) => {\n    scope[branchAccessor] || setConditionalRenderer(\n      scope,\n      nodeAccessor,\n      tryContent,\n      createAndSetupBranch\n    );\n    let branch = scope[branchAccessor];\n    branch && (branch.a = nodeAccessor, branch.b = normalizeDynamicRenderer(input.catch), branch.d = normalizeDynamicRenderer(\n      input.placeholder\n    ));\n  };\n}\nfunction renderCatch(scope, error) {\n  let tryWithCatch = findBranchWithKey(scope, \"b\" /* CatchContent */);\n  if (tryWithCatch) {\n    let owner = tryWithCatch._, placeholderBranch = tryWithCatch.c;\n    placeholderBranch && (tryWithCatch.n = 0, owner[\"d\" /* ConditionalScope */ + tryWithCatch.a] = placeholderBranch, destroyBranch(tryWithCatch)), caughtError.add(pendingEffects), setConditionalRenderer(\n      owner,\n      tryWithCatch.a,\n      tryWithCatch.b,\n      createAndSetupBranch\n    ), tryWithCatch.b.l?.(\n      owner[\"d\" /* ConditionalScope */ + tryWithCatch.a],\n      [error]\n    );\n  } else\n    throw error;\n}\nfunction conditional(nodeAccessor, ...branches) {\n  let branchAccessor = \"c\" /* ConditionalRenderer */ + nodeAccessor;\n  return (scope, newBranch) => {\n    newBranch !== scope[branchAccessor] && setConditionalRenderer(\n      scope,\n      nodeAccessor,\n      branches[scope[branchAccessor] = newBranch],\n      createAndSetupBranch\n    );\n  };\n}\nfunction patchDynamicTag(fn) {\n  dynamicTag = fn(dynamicTag);\n}\nvar dynamicTag = function(nodeAccessor, getContent, getTagVar, inputIsArgs) {\n  let childScopeAccessor = \"d\" /* ConditionalScope */ + nodeAccessor, rendererAccessor = \"c\" /* ConditionalRenderer */ + nodeAccessor;\n  return (scope, newRenderer, getInput) => {\n    let normalizedRenderer = normalizeDynamicRenderer(newRenderer);\n    if (scope[rendererAccessor] !== (scope[rendererAccessor] = normalizedRenderer?.m || normalizedRenderer) || getContent && !(normalizedRenderer || scope[childScopeAccessor]))\n      if (setConditionalRenderer(\n        scope,\n        nodeAccessor,\n        normalizedRenderer || (getContent ? getContent(scope) : void 0),\n        createBranchWithTagNameOrRenderer\n      ), getTagVar && setTagVar(scope, childScopeAccessor, getTagVar()), typeof normalizedRenderer == \"string\") {\n        if (getContent) {\n          let content = getContent(scope);\n          setConditionalRenderer(\n            scope[childScopeAccessor],\n            0,\n            content,\n            createAndSetupBranch\n          ), content.y && subscribeToScopeSet(\n            content.x,\n            content.y,\n            scope[childScopeAccessor][\"d\" /* ConditionalScope */ + 0]\n          );\n        }\n      } else normalizedRenderer?.y && subscribeToScopeSet(\n        normalizedRenderer.x,\n        normalizedRenderer.y,\n        scope[childScopeAccessor]\n      );\n    if (normalizedRenderer) {\n      let args = getInput?.();\n      if (typeof normalizedRenderer == \"string\")\n        attrs(\n          scope[childScopeAccessor],\n          0,\n          (inputIsArgs ? args[0] : args) || {}\n        );\n      else if (normalizedRenderer.l)\n        if (inputIsArgs)\n          normalizedRenderer.l(\n            scope[childScopeAccessor],\n            normalizedRenderer._ ? args[0] : args\n          );\n        else {\n          let inputWithContent = getContent ? { ...args, content: getContent(scope) } : args || {};\n          normalizedRenderer.l(\n            scope[childScopeAccessor],\n            normalizedRenderer._ ? inputWithContent : [inputWithContent]\n          );\n        }\n    }\n  };\n};\nfunction setConditionalRenderer(scope, nodeAccessor, newRenderer, createBranch2) {\n  let referenceNode = scope[nodeAccessor], prevBranch = scope[\"d\" /* ConditionalScope */ + nodeAccessor], parentNode = referenceNode.nodeType > 1 /* Element */ ? (prevBranch?.h || referenceNode).parentNode : referenceNode, newBranch = scope[\"d\" /* ConditionalScope */ + nodeAccessor] = newRenderer && createBranch2(scope.$global, newRenderer, scope, parentNode);\n  referenceNode === parentNode ? (prevBranch && (destroyBranch(prevBranch), referenceNode.textContent = \"\"), newBranch && insertBranchBefore(newBranch, parentNode, null)) : prevBranch ? (newBranch ? insertBranchBefore(newBranch, parentNode, prevBranch.h) : parentNode.insertBefore(referenceNode, prevBranch.h), removeAndDestroyBranch(prevBranch)) : newBranch && (insertBranchBefore(newBranch, parentNode, referenceNode), referenceNode.remove());\n}\nfunction loopOf(nodeAccessor, renderer) {\n  return loop(\n    nodeAccessor,\n    renderer,\n    ([all, by = bySecondArg], cb) => {\n      typeof by == \"string\" ? forOf(\n        all,\n        (item, i) => cb(item[by], [item, i])\n      ) : forOf(all, (item, i) => cb(by(item, i), [item, i]));\n    }\n  );\n}\nfunction loopIn(nodeAccessor, renderer) {\n  return loop(\n    nodeAccessor,\n    renderer,\n    ([obj, by = byFirstArg], cb) => forIn(obj, (key, value2) => cb(by(key, value2), [key, value2]))\n  );\n}\nfunction loopTo(nodeAccessor, renderer) {\n  return loop(\n    nodeAccessor,\n    renderer,\n    ([to, from, step, by = byFirstArg], cb) => forTo(to, from, step, (v) => cb(by(v), [v]))\n  );\n}\nfunction loop(nodeAccessor, renderer, forEach) {\n  let params = renderer.l;\n  return (scope, value2) => {\n    let referenceNode = scope[nodeAccessor], oldMap = scope[\"m\" /* LoopScopeMap */ + nodeAccessor], oldArray = oldMap ? scope[\"l\" /* LoopScopeArray */ + nodeAccessor] || [\n      ...oldMap.values()\n    ] : [], parentNode = referenceNode.nodeType > 1 /* Element */ ? referenceNode.parentNode || oldArray[0].h.parentNode : referenceNode, newMap = scope[\"m\" /* LoopScopeMap */ + nodeAccessor] = /* @__PURE__ */ new Map(), newArray = scope[\"l\" /* LoopScopeArray */ + nodeAccessor] = [];\n    forEach(value2, (key, args) => {\n      let branch = oldMap?.get(key) || createAndSetupBranch(scope.$global, renderer, scope, parentNode);\n      params?.(branch, args), newMap.set(key, branch), newArray.push(branch);\n    });\n    let afterReference = null;\n    referenceNode !== parentNode && (oldArray.length ? (afterReference = oldArray[oldArray.length - 1].j.nextSibling, newArray.length || parentNode.insertBefore(referenceNode, afterReference)) : newArray.length && (afterReference = referenceNode.nextSibling, referenceNode.remove())), reconcile(parentNode, oldArray, newArray, afterReference);\n  };\n}\nfunction createBranchWithTagNameOrRenderer($global, tagNameOrRenderer, parentScope, parentNode) {\n  let branch = createBranch(\n    $global,\n    tagNameOrRenderer,\n    parentScope,\n    parentNode\n  );\n  return typeof tagNameOrRenderer == \"string\" ? branch[0] = branch.h = branch.j = document.createElementNS(\n    tagNameOrRenderer === \"svg\" ? \"http://www.w3.org/2000/svg\" : tagNameOrRenderer === \"math\" ? \"http://www.w3.org/1998/Math/MathML\" : parentNode.namespaceURI,\n    tagNameOrRenderer\n  ) : setupBranch(tagNameOrRenderer, branch), branch;\n}\nfunction bySecondArg(_item, index) {\n  return index;\n}\nfunction byFirstArg(name) {\n  return name;\n}\n\n// src/dom/queue.ts\nvar pendingRenders = [], pendingRendersLookup = /* @__PURE__ */ new Map(), caughtError = /* @__PURE__ */ new WeakSet(), placeholderShown = /* @__PURE__ */ new WeakSet(), pendingEffects = [], rendering, scopeKeyOffset = 1e3;\nfunction queueRender(scope, signal, signalKey, value2, scopeKey = scope.m) {\n  let key = scopeKey * scopeKeyOffset + signalKey, existingRender = signalKey >= 0 && pendingRendersLookup.get(key);\n  if (existingRender)\n    existingRender.I = value2;\n  else {\n    let render = {\n      q: key,\n      D: scope,\n      L: signal,\n      I: value2\n    }, i = pendingRenders.push(render) - 1;\n    for (; i; ) {\n      let parentIndex = i - 1 >> 1, parent = pendingRenders[parentIndex];\n      if (key - parent.q >= 0) break;\n      pendingRenders[i] = parent, i = parentIndex;\n    }\n    signalKey >= 0 && pendingRendersLookup.set(key, render), pendingRenders[i] = render;\n  }\n}\nfunction queueEffect(scope, fn) {\n  pendingEffects.push(fn, scope);\n}\nfunction run() {\n  let effects = pendingEffects;\n  try {\n    rendering = 1, runRenders();\n  } finally {\n    pendingRenders = [], pendingRendersLookup = /* @__PURE__ */ new Map(), pendingEffects = [], rendering = 0;\n  }\n  runEffects(effects);\n}\nfunction prepareEffects(fn) {\n  let prevRenders = pendingRenders, prevRendersLookup = pendingRendersLookup, prevEffects = pendingEffects, preparedEffects = pendingEffects = [];\n  pendingRenders = [], pendingRendersLookup = /* @__PURE__ */ new Map();\n  try {\n    rendering = 1, fn(), runRenders();\n  } finally {\n    rendering = 0, pendingRenders = prevRenders, pendingRendersLookup = prevRendersLookup, pendingEffects = prevEffects;\n  }\n  return preparedEffects;\n}\nvar runEffects = (effects) => {\n  for (let i = 0, scope; i < effects.length; )\n    effects[i++](\n      scope = effects[i++],\n      scope\n    );\n};\nfunction runRenders() {\n  for (; pendingRenders.length; ) {\n    let render = pendingRenders[0], item = pendingRenders.pop();\n    if (render !== item) {\n      let i = 0, mid = pendingRenders.length >> 1, key = (pendingRenders[0] = item).q;\n      for (; i < mid; ) {\n        let bestChild = (i << 1) + 1, right = bestChild + 1;\n        if (right < pendingRenders.length && pendingRenders[right].q - pendingRenders[bestChild].q < 0 && (bestChild = right), pendingRenders[bestChild].q - key >= 0)\n          break;\n        pendingRenders[i] = pendingRenders[bestChild], i = bestChild;\n      }\n      pendingRenders[i] = item;\n    }\n    render.D.k?.A || runRender(render);\n  }\n  finishPendingScopes();\n}\nvar runRender = (render) => render.L(render.D, render.I), enableCatch = () => {\n  enableCatch = () => {\n  };\n  let handlePendingTry = (fn, scope, branch) => {\n    for (; branch; ) {\n      if (branch.n)\n        return (branch.H ||= []).push(fn, scope);\n      branch = branch.t;\n    }\n  };\n  runEffects = /* @__PURE__ */ ((runEffects2) => (effects, checkPending = placeholderShown.has(effects)) => {\n    if (checkPending || caughtError.has(effects)) {\n      let i = 0, fn, scope, branch;\n      for (; i < effects.length; )\n        fn = effects[i++], scope = effects[i++], branch = scope.k, !branch?.A && !(checkPending && handlePendingTry(fn, scope, branch)) && fn(scope, scope);\n    } else\n      runEffects2(effects);\n  })(runEffects), runRender = /* @__PURE__ */ ((runRender2) => (render) => {\n    try {\n      runRender2(render);\n    } catch (error) {\n      renderCatch(render.D, error);\n    }\n  })(runRender);\n};\n\n// src/dom/abort-signal.ts\nfunction resetAbortSignal(scope, id) {\n  let ctrl = scope.u?.[id];\n  ctrl && (queueEffect(ctrl, abort), scope.u[id] = void 0);\n}\nfunction getAbortSignal(scope, id) {\n  return scope.k && (scope.k.J ||= /* @__PURE__ */ new Set()).add(scope), ((scope.u ||= {})[id] ||= new AbortController()).signal;\n}\nfunction abort(ctrl) {\n  ctrl.abort();\n}\n\n// src/common/compat-meta.ts\nvar prefix = \"$C_\", RENDERER_REGISTER_ID = prefix + \"r\", SET_SCOPE_REGISTER_ID = prefix + \"s\", RENDER_BODY_ID = prefix + \"b\";\n\n// src/dom/compat.ts\nvar classIdToBranch = /* @__PURE__ */ new Map(), compat = {\n  patchDynamicTag,\n  queueEffect,\n  init(warp10Noop) {\n    register(SET_SCOPE_REGISTER_ID, (branch) => {\n      classIdToBranch.set(branch.m5c, branch);\n    }), register(RENDER_BODY_ID, warp10Noop);\n  },\n  registerRenderer(fn) {\n    register(RENDERER_REGISTER_ID, fn);\n  },\n  isRenderer(renderer) {\n    return renderer.B;\n  },\n  getStartNode(branch) {\n    return branch.h;\n  },\n  setScopeNodes(branch, startNode, endNode) {\n    branch.h = startNode, branch.j = endNode;\n  },\n  runComponentEffects() {\n    runEffects(this.effects);\n  },\n  runComponentDestroy() {\n    this.scope && destroyBranch(this.scope);\n  },\n  resolveRegistered(value2, {\n    runtimeId,\n    componentIdPrefix\n  }) {\n    return Array.isArray(value2) && typeof value2[0] == \"string\" ? getRegisteredWithScope(\n      value2[0],\n      value2.length === 2 && window[runtimeId]?.[componentIdPrefix === \"s\" ? \"_\" : componentIdPrefix]?.s[value2[1]]\n    ) : value2;\n  },\n  createRenderer(params, clone) {\n    let renderer = createRenderer(0, 0, 0, params);\n    return renderer.B = (branch) => {\n      let cloned = clone();\n      branch.h = cloned.startNode, branch.j = cloned.endNode;\n    }, renderer;\n  },\n  render(out, component, renderer, args) {\n    let branch = component.scope;\n    branch || (branch = classIdToBranch.get(component.id), branch && (component.scope = branch, classIdToBranch.delete(component.id)));\n    let existing;\n    if (typeof args[0] == \"object\" && \"renderBody\" in args[0]) {\n      let input = args[0], normalizedInput = args[0] = {};\n      for (let key in input)\n        normalizedInput[key === \"renderBody\" ? \"content\" : key] = input[key];\n    }\n    if (component.effects = prepareEffects(() => {\n      branch ? existing = 1 : (out.global.o ||= 0, branch = component.scope = createAndSetupBranch(\n        out.global,\n        renderer,\n        renderer.x,\n        document.body\n      )), renderer.l?.(branch, renderer._ ? args[0] : args);\n    }), !existing)\n      return toInsertNode(branch.h, branch.j);\n  }\n};\n\n// src/dom/template.ts\nvar createTemplate = (id, template, walks, setup, inputSignal) => {\n  let renderer = createContent(\n    id,\n    template,\n    walks,\n    setup,\n    inputSignal\n  )();\n  return renderer.mount = mount, renderer._ = renderer, register(id, renderer);\n};\nfunction mount(input = {}, reference, position) {\n  let branch, parentNode = reference, nextSibling = null, { $global } = input;\n  switch ($global ? ({ $global, ...input } = input, $global = {\n    o: 0,\n    runtimeId: DEFAULT_RUNTIME_ID,\n    renderId: DEFAULT_RENDER_ID,\n    ...$global\n  }) : $global = {\n    o: 0,\n    runtimeId: DEFAULT_RUNTIME_ID,\n    renderId: DEFAULT_RENDER_ID\n  }, position) {\n    case \"beforebegin\":\n      parentNode = reference.parentNode, nextSibling = reference;\n      break;\n    case \"afterbegin\":\n      nextSibling = reference.firstChild;\n      break;\n    case \"afterend\":\n      parentNode = reference.parentNode, nextSibling = reference.nextSibling;\n      break;\n  }\n  let args = this.l, effects = prepareEffects(() => {\n    branch = createBranch(\n      $global,\n      this,\n      void 0,\n      parentNode\n    ), this.C?.(branch), args?.(branch, input);\n  });\n  return insertChildNodes(\n    parentNode,\n    nextSibling,\n    branch.h,\n    branch.j\n  ), runEffects(effects), {\n    update(newInput) {\n      args && runEffects(\n        prepareEffects(() => {\n          args(branch, newInput);\n        })\n      );\n    },\n    destroy() {\n      removeAndDestroyBranch(branch);\n    }\n  };\n}\nexport {\n  attr,\n  attrTag,\n  attrTags,\n  attrs,\n  attrsEvents,\n  awaitTag,\n  classAttr,\n  compat,\n  conditional,\n  conditionalClosure,\n  controllable_detailsOrDialog_open,\n  controllable_detailsOrDialog_open_effect,\n  controllable_input_checked,\n  controllable_input_checkedValue,\n  controllable_input_checkedValue_effect,\n  controllable_input_checked_effect,\n  controllable_input_value,\n  controllable_input_value_effect,\n  controllable_select_value,\n  controllable_select_value_effect,\n  controllable_input_value as controllable_textarea_value,\n  controllable_input_value_effect as controllable_textarea_value_effect,\n  createContent,\n  createRenderer,\n  createTemplate,\n  createTry,\n  data,\n  dynamicClosure,\n  dynamicClosureRead,\n  dynamicTag,\n  effect,\n  enableCatch,\n  forIn,\n  forOf,\n  forTo,\n  getAbortSignal,\n  hoist,\n  html,\n  init,\n  intersection,\n  lifecycle,\n  loopClosure,\n  loopIn,\n  loopOf,\n  loopTo,\n  nextTagId,\n  nodeRef,\n  on,\n  partialAttrs,\n  props,\n  register,\n  registerBoundSignal,\n  registerContent,\n  resetAbortSignal,\n  run,\n  setTagVar,\n  setTagVarChange,\n  state,\n  styleAttr,\n  tagVarSignal,\n  tagVarSignalChange,\n  textContent,\n  value\n};\n"],"names":["styleValue","value2","toDelimitedString","stringifyStyleObject","name","val","delimiter","stringify","result","curDelimiter","v","part","DEFAULT_RUNTIME_ID","registeredValues","init","runtimeId","renders","defineRuntime","desc","resumeRender","initRuntime","renders2","renderId","render","walk2","commentPrefixLen","branchStack","scopeLookup","serializeContext","branchIds","parentBranchIds","currentBranchId","$global","lastScopeId","visits","resumes","visitNodes","lastEndNode","branchEnd","branchId","reference","branch","endNode","visit","commentText","dataIndex","scopeId","scope","data2","token","node","curParent","startNode","next","curNode","start","childScopeId","isResuming","i","serialized","prevScope","parentBranchId","parentBranch","register","id","obj","setAttribute","element","styleAttr","pendingScopes","finishPendingScopes","port2","port1","port22","isScheduled","run","schedule","flushAndWaitFrame","triggerMacroTask","state","valueAccessor","fn","valueChangeAccessor","update","valueChange","rendering","queueRender","intersection","defaultPending","scopeIdAccessor","effect","queueEffect","pendingRenders","pendingRendersLookup","pendingEffects","scopeKeyOffset","signal","signalKey","scopeKey","key","existingRender","parentIndex","parent","effects","runRenders","runEffects","item","mid","bestChild","right","runRender","getAbortSignal"],"mappings":"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","x_google_ignoreList":[0]}